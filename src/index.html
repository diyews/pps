<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>皮皮烁</title>
	<style type="text/css">
        html {height: 100%;width: 100%}
        img {height:100%;width: 100%;background-size: 100% 100%;}
		body {
			margin: 0px;
			height: 100%;
			width: 100%;
			overflow: hidden;
			/*background: -moz-radial-gradient(center, ellipse cover, rgba(255,197,120,1) 0%, rgba(251,157,35,1) 100%);*/
			/*background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%,rgba(255,197,120,1)), color-stop(100%,rgba(251,157,35,1)));*/
			/*background: -webkit-radial-gradient(center, ellipse cover, rgba(255,197,120,1) 0%,rgba(251,157,35,1) 100%);*/
			/*background: -o-radial-gradient(center, ellipse cover, rgba(255,197,120,1) 0%,rgba(251,157,35,1) 100%);*/
			/*background: -ms-radial-gradient(center, ellipse cover, rgba(255,197,120,1) 0%,rgba(251,157,35,1) 100%);*/
			/*background: radial-gradient(ellipse at center, rgba(255,197,120,1) 0%,rgba(251,157,35,1) 100%);*/
		}

		canvas {
			height: 100%;
		}
	</style>
</head>
<body>
<img id="background" alt="background" src="img/LWDAa.jpg" crossorigin="anonymous">
<canvas id='canvas' style="position:fixed;top: 0;
    z-index: 1000;"></canvas>
<script>
	//rainday.js
	/**
	 * Defines a new instance of the rainyday.js.
	 * @param options options element with script parameters
	 * @param canvas to be used (if not defined a new one will be created)
	 */

	function RainyDay(options, canvas) {

		if (this === window) { //if *this* is the window object, start over with a *new* object
			return new RainyDay(options);
		}

		this.img = options.image;
		var defaults = {
			opacity: 1,
			blur: 10,
			crop: [0, 0, this.img.naturalWidth, this.img.naturalHeight],
			enableSizeChange: true,
			parentElement: document.getElementsByTagName('body')[0],
			fps: 30,
			fillStyle: '#8ED6FF',
			enableCollisions: true,
			gravityThreshold: 3,
			gravityAngle: Math.PI / 2,
			gravityAngleVariance: 0,
			reflectionScaledownFactor: 5,
			reflectionDropMappingWidth: 200,
			reflectionDropMappingHeight: 200,
			width: this.img.clientWidth,
			height: this.img.clientHeight,
			position: 'absolute',
			top: 0,
			left: 0
		};

		// add the defaults to options
		for (var option in defaults) {
			if (typeof options[option] === 'undefined') {
				options[option] = defaults[option];
			}
		}
		this.options = options;

		this.drops = [];

		// prepare canvas elements
		this.canvas = canvas || this.prepareCanvas();
		this.prepareBackground(this.canvas.width, this.canvas.height);
		this.prepareGlass();

		// assume defaults
		this.reflection = this.REFLECTION_MINIATURE;
		this.trail = this.TRAIL_DROPS;
		this.gravity = this.GRAVITY_NON_LINEAR;
		this.collision = this.COLLISION_SIMPLE;

		// set polyfill of requestAnimationFrame
		this.setRequestAnimFrame();
	}

	/**
	 * Create the main canvas over a given element
	 * @returns HTMLElement the canvas
	 */
	RainyDay.prototype.prepareCanvas = function() {
		var canvas = document.createElement('canvas');
		canvas.style.position = this.options.position;
		canvas.style.top = this.options.top;
		canvas.style.left = this.options.left;
		canvas.width = this.options.width;
		canvas.height = this.options.height;
		this.options.parentElement.appendChild(canvas);
		if (this.enableSizeChange) {
			this.setResizeHandler();
		}
		return canvas;
	};

	RainyDay.prototype.setResizeHandler = function() {
		// use setInterval if oneresize event already use by other.
		if (window.onresize !== null) {
			window.setInterval(this.checkSize.bind(this), 100);
		} else {
			window.onresize = this.checkSize.bind(this);
			window.onorientationchange = this.checkSize.bind(this);
		}
	};

	/**
	 * Periodically check the size of the underlying element
	 */
	RainyDay.prototype.checkSize = function() {
		var clientWidth = this.img.clientWidth;
		var clientHeight = this.img.clientHeight;
		var clientOffsetLeft = this.img.offsetLeft;
		var clientOffsetTop = this.img.offsetTop;
		var canvasWidth = this.canvas.width;
		var canvasHeight = this.canvas.height;
		var canvasOffsetLeft = this.canvas.offsetLeft;
		var canvasOffsetTop = this.canvas.offsetTop;

		if (canvasWidth !== clientWidth || canvasHeight !== clientHeight) {
			this.canvas.width = this.canvas.width;
			this.canvas.height = this.canvas.height;
			this.prepareBackground(this.canvas.width, this.canvas.height);
			this.glass.width = this.canvas.width;
			this.glass.height = this.canvas.height;
			this.prepareReflections();
		}
		if (canvasOffsetLeft !== clientOffsetLeft || canvasOffsetTop !== clientOffsetTop) {
			this.canvas.offsetLeft = clientOffsetLeft;
			this.canvas.offsetTop = clientOffsetTop;
		}
	};

	/**
	 * Start animation loop
	 */
	RainyDay.prototype.animateDrops = function() {
		if (this.addDropCallback) {
			this.addDropCallback();
		}
		// |this.drops| array may be changed as we iterate over drops
		var dropsClone = this.drops.slice();
		var newDrops = [];
		for (var i = 0; i < dropsClone.length; ++i) {
			if (dropsClone[i].animate()) {
				newDrops.push(dropsClone[i]);
			}
		}
		this.drops = newDrops;
		window.requestAnimFrame(this.animateDrops.bind(this));
	};

	/**
	 * Polyfill for requestAnimationFrame
	 */
	RainyDay.prototype.setRequestAnimFrame = function() {
		var fps = this.options.fps;
		window.requestAnimFrame = (function() {
			return window.requestAnimationFrame ||
					window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					function(callback) {
						window.setTimeout(callback, 1000 / fps);
					};
		})();
	};

	/**
	 * Create the helper canvas for rendering raindrop reflections.
	 */
	RainyDay.prototype.prepareReflections = function() {
		this.reflected = document.createElement('canvas');
		this.reflected.width = this.canvas.width / this.options.reflectionScaledownFactor;
		this.reflected.height = this.canvas.height / this.options.reflectionScaledownFactor;
		var ctx = this.reflected.getContext('2d');
		ctx.drawImage(this.img, this.options.crop[0], this.options.crop[1], this.options.crop[2], this.options.crop[3], 0, 0, this.reflected.width, this.reflected.height);
	};

	/**
	 * Create the glass canvas.
	 */
	RainyDay.prototype.prepareGlass = function() {
		this.glass = document.createElement('canvas');
		this.glass.width = this.canvas.width;
		this.glass.height = this.canvas.height;
		this.context = this.glass.getContext('2d');
	};

	/**
	 * Main function for starting rain rendering.
	 * @param presets list of presets to be applied
	 * @param speed speed of the animation (if not provided or 0 static image will be generated)
	 */
	RainyDay.prototype.rain = function(presets, speed) {
		// prepare canvas for drop reflections
		if (this.reflection !== this.REFLECTION_NONE) {
			this.prepareReflections();
		}

		this.animateDrops();

		// animation
		this.presets = presets;

		this.PRIVATE_GRAVITY_FORCE_FACTOR_Y = (this.options.fps * 0.001) / 25;
		this.PRIVATE_GRAVITY_FORCE_FACTOR_X = ((Math.PI / 2) - this.options.gravityAngle) * (this.options.fps * 0.001) / 50;

		// prepare gravity matrix
		if (this.options.enableCollisions) {

			// calculate max radius of a drop to establish gravity matrix resolution
			var maxDropRadius = 0;
			for (var i = 0; i < presets.length; i++) {
				if (presets[i][0] + presets[i][1] > maxDropRadius) {
					maxDropRadius = Math.floor(presets[i][0] + presets[i][1]);
				}
			}

			if (maxDropRadius > 0) {
				// initialize the gravity matrix
				var mwi = Math.ceil(this.canvas.width / maxDropRadius);
				var mhi = Math.ceil(this.canvas.height / maxDropRadius);
				this.matrix = new CollisionMatrix(mwi, mhi, maxDropRadius);
			} else {
				this.options.enableCollisions = false;
			}
		}

		for (var i = 0; i < presets.length; i++) {
			if (!presets[i][3]) {
				presets[i][3] = -1;
			}
		}

		var lastExecutionTime = 0;
		this.addDropCallback = function() {
			var timestamp = new Date().getTime();
			if (timestamp - lastExecutionTime < speed) {
				return;
			}
			lastExecutionTime = timestamp;
			var context = this.canvas.getContext('2d');
			context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			context.drawImage(this.background, 0, 0, this.canvas.width, this.canvas.height);
			// select matching preset
			var preset;
			for (var i = 0; i < presets.length; i++) {
				if (presets[i][2] > 1 || presets[i][3] === -1) {
					if (presets[i][3] !== 0) {
						presets[i][3]--;
						for (var y = 0; y < presets[i][2]; ++y) {
							this.putDrop(new Drop(this, Math.random() * this.canvas.width, Math.random() * this.canvas.height, presets[i][0], presets[i][1]));
						}
					}
				} else if (Math.random() < presets[i][2]) {
					preset = presets[i];
					break;
				}
			}
			if (preset) {
				this.putDrop(new Drop(this, Math.random() * this.canvas.width, Math.random() * this.canvas.height, preset[0], preset[1]));
			}
			context.save();
			context.globalAlpha = this.opacity;
			context.drawImage(this.glass, 0, 0, this.canvas.width, this.canvas.height);
			context.restore();
		}
				.bind(this);
	};

	/**
	 * Adds a new raindrop to the animation.
	 * @param drop drop object to be added to the animation
	 */
	RainyDay.prototype.putDrop = function(drop) {
		drop.draw();
		if (this.gravity && drop.r > this.options.gravityThreshold) {
			if (this.options.enableCollisions) {
				this.matrix.update(drop);
			}
			this.drops.push(drop);
		}
	};

	/**
	 * Clear the drop and remove from the list if applicable.
	 * @drop to be cleared
	 * @force force removal from the list
	 * result if true animation of this drop should be stopped
	 */
	RainyDay.prototype.clearDrop = function(drop, force) {
		var result = drop.clear(force);
		if (result) {
			var index = this.drops.indexOf(drop);
			if (index >= 0) {
				this.drops.splice(index, 1);
			}
		}
		return result;
	};

	/**
	 * Defines a new raindrop object.
	 * @param rainyday reference to the parent object
	 * @param centerX x position of the center of this drop
	 * @param centerY y position of the center of this drop
	 * @param min minimum size of a drop
	 * @param base base value for randomizing drop size
	 */

	function Drop(rainyday, centerX, centerY, min, base) {
		this.x = Math.floor(centerX);
		this.y = Math.floor(centerY);
		this.r = (Math.random() * base) + min;
		this.rainyday = rainyday;
		this.context = rainyday.context;
		this.reflection = rainyday.reflected;
	}

	/**
	 * Draws a raindrop on canvas at the current position.
	 */
	Drop.prototype.draw = function() {
		this.context.save();
		this.context.beginPath();

		var orgR = this.r;
		this.r = 0.95 * this.r;
		if (this.r < 3) {
			this.context.arc(this.x, this.y, this.r, 0, Math.PI * 2, true);
			this.context.closePath();
		} else if (this.colliding || this.yspeed > 2) {
			if (this.colliding) {
				var collider = this.colliding;
				this.r = 1.001 * (this.r > collider.r ? this.r : collider.r);
				this.x += (collider.x - this.x);
				this.colliding = null;
			}

			var yr = 1 + 0.1 * this.yspeed;
			this.context.moveTo(this.x - this.r / yr, this.y);
			this.context.bezierCurveTo(this.x - this.r, this.y - this.r * 2, this.x + this.r, this.y - this.r * 2, this.x + this.r / yr, this.y);
			this.context.bezierCurveTo(this.x + this.r, this.y + yr * this.r, this.x - this.r, this.y + yr * this.r, this.x - this.r / yr, this.y);
		} else {
			this.context.arc(this.x, this.y, this.r * 0.9, 0, Math.PI * 2, true);
			this.context.closePath();
		}

		this.context.clip();

		this.r = orgR;

		if (this.rainyday.reflection) {
			this.rainyday.reflection(this);
		}

		this.context.restore();
	};

	/**
	 * Clears the raindrop region.
	 * @param force force stop
	 * @returns Boolean true if the animation is stopped
	 */
	Drop.prototype.clear = function(force) {
		this.context.clearRect(this.x - this.r - 1, this.y - this.r - 2, 2 * this.r + 2, 2 * this.r + 2);
		if (force) {
			this.terminate = true;
			return true;
		}
		if ((this.y - this.r > this.rainyday.h) || (this.x - this.r > this.rainyday.w) || (this.x + this.r < 0)) {
			// over edge so stop this drop
			return true;
		}
		return false;
	};

	/**
	 * Moves the raindrop to a new position according to the gravity.
	 */
	Drop.prototype.animate = function() {
		if (this.terminate) {
			return false;
		}
		var stopped = this.rainyday.gravity(this);
		if (!stopped && this.rainyday.trail) {
			this.rainyday.trail(this);
		}
		if (this.rainyday.options.enableCollisions) {
			var collisions = this.rainyday.matrix.update(this, stopped);
			if (collisions) {
				this.rainyday.collision(this, collisions);
			}
		}
		return !stopped || this.terminate;
	};

	/**
	 * TRAIL function: no trail at all
	 */
	RainyDay.prototype.TRAIL_NONE = function() {
		// nothing going on here
	};

	/**
	 * TRAIL function: trail of small drops (default)
	 * @param drop raindrop object
	 */
	RainyDay.prototype.TRAIL_DROPS = function(drop) {
		if (!drop.trailY || drop.y - drop.trailY >= Math.random() * 100 * drop.r) {
			drop.trailY = drop.y;
			this.putDrop(new Drop(this, drop.x + (Math.random() * 2 - 1) * Math.random(), drop.y - drop.r - 5, Math.ceil(drop.r / 5), 0));
		}
	};

	/**
	 * TRAIL function: trail of unblurred image
	 * @param drop raindrop object
	 */
	RainyDay.prototype.TRAIL_SMUDGE = function(drop) {
		var y = drop.y - drop.r - 3;
		var x = drop.x - drop.r / 2 + (Math.random() * 2);
		if (y < 0 || x < 0) {
			return;
		}
		this.context.drawImage(this.clearbackground, x, y, drop.r, 2, x, y, drop.r, 2);
	};

	/**
	 * GRAVITY function: no gravity at all
	 * @returns Boolean true if the animation is stopped
	 */
	RainyDay.prototype.GRAVITY_NONE = function() {
		return true;
	};

	/**
	 * GRAVITY function: linear gravity
	 * @param drop raindrop object
	 * @returns Boolean true if the animation is stopped
	 */
	RainyDay.prototype.GRAVITY_LINEAR = function(drop) {
		if (this.clearDrop(drop)) {
			return true;
		}

		if (drop.yspeed) {
			drop.yspeed += this.PRIVATE_GRAVITY_FORCE_FACTOR_Y * Math.floor(drop.r);
			drop.xspeed += this.PRIVATE_GRAVITY_FORCE_FACTOR_X * Math.floor(drop.r);
		} else {
			drop.yspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_Y;
			drop.xspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_X;
		}

		drop.y += drop.yspeed;
		drop.draw();
		return false;
	};

	/**
	 * GRAVITY function: non-linear gravity (default)
	 * @param drop raindrop object
	 * @returns Boolean true if the animation is stopped
	 */
	RainyDay.prototype.GRAVITY_NON_LINEAR = function(drop) {
		if (this.clearDrop(drop)) {
			return true;
		}

		if (drop.collided) {
			drop.collided = false;
			drop.seed = Math.floor(drop.r * Math.random() * this.options.fps);
			drop.skipping = false;
			drop.slowing = false;
		} else if (!drop.seed || drop.seed < 0) {
			drop.seed = Math.floor(drop.r * Math.random() * this.options.fps);
			drop.skipping = drop.skipping === false ? true : false;
			drop.slowing = true;
		}

		drop.seed--;

		if (drop.yspeed) {
			if (drop.slowing) {
				drop.yspeed /= 1.1;
				drop.xspeed /= 1.1;
				if (drop.yspeed < this.PRIVATE_GRAVITY_FORCE_FACTOR_Y) {
					drop.slowing = false;
				}

			} else if (drop.skipping) {
				drop.yspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_Y;
				drop.xspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_X;
			} else {
				drop.yspeed += 1 * this.PRIVATE_GRAVITY_FORCE_FACTOR_Y * Math.floor(drop.r);
				drop.xspeed += 1 * this.PRIVATE_GRAVITY_FORCE_FACTOR_X * Math.floor(drop.r);
			}
		} else {
			drop.yspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_Y;
			drop.xspeed = this.PRIVATE_GRAVITY_FORCE_FACTOR_X;
		}

		if (this.options.gravityAngleVariance !== 0) {
			drop.xspeed += ((Math.random() * 2 - 1) * drop.yspeed * this.options.gravityAngleVariance);
		}

		drop.y += drop.yspeed;
		drop.x += drop.xspeed;

		drop.draw();
		return false;
	};

	/**
	 * Utility function to return positive min value
	 * @param val1 first number
	 * @param val2 second number
	 */
	RainyDay.prototype.positiveMin = function(val1, val2) {
		var result = 0;
		if (val1 < val2) {
			if (val1 <= 0) {
				result = val2;
			} else {
				result = val1;
			}
		} else {
			if (val2 <= 0) {
				result = val1;
			} else {
				result = val2;
			}
		}
		return result <= 0 ? 1 : result;
	};

	/**
	 * REFLECTION function: no reflection at all
	 */
	RainyDay.prototype.REFLECTION_NONE = function() {
		this.context.fillStyle = this.options.fillStyle;
		this.context.fill();
	};

	/**
	 * REFLECTION function: miniature reflection (default)
	 * @param drop raindrop object
	 */
	RainyDay.prototype.REFLECTION_MINIATURE = function(drop) {
		var sx = Math.max((drop.x - this.options.reflectionDropMappingWidth) / this.options.reflectionScaledownFactor, 0);
		var sy = Math.max((drop.y - this.options.reflectionDropMappingHeight) / this.options.reflectionScaledownFactor, 0);
		var sw = this.positiveMin(this.options.reflectionDropMappingWidth * 2 / this.options.reflectionScaledownFactor, this.reflected.width - sx);
		var sh = this.positiveMin(this.options.reflectionDropMappingHeight * 2 / this.options.reflectionScaledownFactor, this.reflected.height - sy);
		var dx = Math.max(drop.x - 1.1 * drop.r, 0);
		var dy = Math.max(drop.y - 1.1 * drop.r, 0);
		this.context.drawImage(this.reflected, sx, sy, sw, sh, dx, dy, drop.r * 2, drop.r * 2);
	};

	/**
	 * COLLISION function: default collision implementation
	 * @param drop one of the drops colliding
	 * @param collisions list of potential collisions
	 */
	RainyDay.prototype.COLLISION_SIMPLE = function(drop, collisions) {
		var item = collisions;
		var drop2;
		while (item != null) {
			var p = item.drop;
			if (Math.sqrt(Math.pow(drop.x - p.x, 2) + Math.pow(drop.y - p.y, 2)) < (drop.r + p.r)) {
				drop2 = p;
				break;
			}
			item = item.next;
		}

		if (!drop2) {
			return;
		}

		// rename so that we're dealing with low/high drops
		var higher,
				lower;
		if (drop.y > drop2.y) {
			higher = drop;
			lower = drop2;
		} else {
			higher = drop2;
			lower = drop;
		}

		this.clearDrop(lower);
		// force stopping the second drop
		this.clearDrop(higher, true);
		this.matrix.remove(higher);
		lower.draw();

		lower.colliding = higher;
		lower.collided = true;
	};

	/**
	 * Resizes canvas, draws original image and applies blurring algorithm.
	 */
	RainyDay.prototype.prepareBackground = function() {
		this.background = document.createElement('canvas');
		this.background.width = this.canvas.width;
		this.background.height = this.canvas.height;

		this.clearbackground = document.createElement('canvas');
		this.clearbackground.width = this.canvas.width;
		this.clearbackground.height = this.canvas.height;

		var context = this.background.getContext('2d');
		context.clearRect(0, 0, this.canvas.width, this.canvas.height);

		context.drawImage(this.img, this.options.crop[0], this.options.crop[1], this.options.crop[2], this.options.crop[3], 0, 0, this.canvas.width, this.canvas.height);

		context = this.clearbackground.getContext('2d');
		context.clearRect(0, 0, this.canvas.width, this.canvas.height);
		context.drawImage(this.img, this.options.crop[0], this.options.crop[1], this.options.crop[2], this.options.crop[3], 0, 0, this.canvas.width, this.canvas.height);

		if (!isNaN(this.options.blur) && this.options.blur >= 1) {
			this.stackBlurCanvasRGB(this.canvas.width, this.canvas.height, this.options.blur);
		}
	};

	/**
	 * Implements the Stack Blur Algorithm (@see http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html).
	 * @param width width of the canvas
	 * @param height height of the canvas
	 * @param radius blur radius
	 */
	RainyDay.prototype.stackBlurCanvasRGB = function(width, height, radius) {

		var shgTable = [
			[0, 9],
			[1, 11],
			[2, 12],
			[3, 13],
			[5, 14],
			[7, 15],
			[11, 16],
			[15, 17],
			[22, 18],
			[31, 19],
			[45, 20],
			[63, 21],
			[90, 22],
			[127, 23],
			[181, 24]
		];

		var mulTable = [
			512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
			454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
			482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
			437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
			497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
			320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
			446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
			329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
			505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
			399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
			324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
			268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
			451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
			385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
			332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
			289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
		];

		radius |= 0;

		var context = this.background.getContext('2d');
		var imageData = context.getImageData(0, 0, width, height);
		var pixels = imageData.data;
		var x,
				y,
				i,
				p,
				yp,
				yi,
				yw,
				rSum,
				gSum,
				bSum,
				rOutSum,
				gOutSum,
				bOutSum,
				rInSum,
				gInSum,
				bInSum,
				pr,
				pg,
				pb,
				rbs;
		var radiusPlus1 = radius + 1;
		var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;

		var stackStart = new BlurStack();
		var stackEnd = new BlurStack();
		var stack = stackStart;
		for (i = 1; i < 2 * radius + 1; i++) {
			stack = stack.next = new BlurStack();
			if (i === radiusPlus1) {
				stackEnd = stack;
			}
		}
		stack.next = stackStart;
		var stackIn = null;
		var stackOut = null;

		yw = yi = 0;

		var mulSum = mulTable[radius];
		var shgSum;
		for (var ssi = 0; ssi < shgTable.length; ++ssi) {
			if (radius <= shgTable[ssi][0]) {
				shgSum = shgTable[ssi - 1][1];
				break;
			}
		}

		for (y = 0; y < height; y++) {
			rInSum = gInSum = bInSum = rSum = gSum = bSum = 0;

			rOutSum = radiusPlus1 * (pr = pixels[yi]);
			gOutSum = radiusPlus1 * (pg = pixels[yi + 1]);
			bOutSum = radiusPlus1 * (pb = pixels[yi + 2]);

			rSum += sumFactor * pr;
			gSum += sumFactor * pg;
			bSum += sumFactor * pb;

			stack = stackStart;

			for (i = 0; i < radiusPlus1; i++) {
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}

			for (i = 1; i < radiusPlus1; i++) {
				p = yi + ((width - 1 < i ? width - 1 : i) << 2);
				rSum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
				gSum += (stack.g = (pg = pixels[p + 1])) * rbs;
				bSum += (stack.b = (pb = pixels[p + 2])) * rbs;

				rInSum += pr;
				gInSum += pg;
				bInSum += pb;

				stack = stack.next;
			}

			stackIn = stackStart;
			stackOut = stackEnd;
			for (x = 0; x < width; x++) {
				pixels[yi] = (rSum * mulSum) >> shgSum;
				pixels[yi + 1] = (gSum * mulSum) >> shgSum;
				pixels[yi + 2] = (bSum * mulSum) >> shgSum;

				rSum -= rOutSum;
				gSum -= gOutSum;
				bSum -= bOutSum;

				rOutSum -= stackIn.r;
				gOutSum -= stackIn.g;
				bOutSum -= stackIn.b;

				p = (yw + ((p = x + radius + 1) < (width - 1) ? p : (width - 1))) << 2;

				rInSum += (stackIn.r = pixels[p]);
				gInSum += (stackIn.g = pixels[p + 1]);
				bInSum += (stackIn.b = pixels[p + 2]);

				rSum += rInSum;
				gSum += gInSum;
				bSum += bInSum;

				stackIn = stackIn.next;

				rOutSum += (pr = stackOut.r);
				gOutSum += (pg = stackOut.g);
				bOutSum += (pb = stackOut.b);

				rInSum -= pr;
				gInSum -= pg;
				bInSum -= pb;

				stackOut = stackOut.next;

				yi += 4;
			}
			yw += width;
		}

		for (x = 0; x < width; x++) {
			gInSum = bInSum = rInSum = gSum = bSum = rSum = 0;

			yi = x << 2;
			rOutSum = radiusPlus1 * (pr = pixels[yi]);
			gOutSum = radiusPlus1 * (pg = pixels[yi + 1]);
			bOutSum = radiusPlus1 * (pb = pixels[yi + 2]);

			rSum += sumFactor * pr;
			gSum += sumFactor * pg;
			bSum += sumFactor * pb;

			stack = stackStart;

			for (i = 0; i < radiusPlus1; i++) {
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}

			yp = width;

			for (i = 1; i < radiusPlus1; i++) {
				yi = (yp + x) << 2;

				rSum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
				gSum += (stack.g = (pg = pixels[yi + 1])) * rbs;
				bSum += (stack.b = (pb = pixels[yi + 2])) * rbs;

				rInSum += pr;
				gInSum += pg;
				bInSum += pb;

				stack = stack.next;

				if (i < (height - 1)) {
					yp += width;
				}
			}

			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for (y = 0; y < height; y++) {
				p = yi << 2;
				pixels[p] = (rSum * mulSum) >> shgSum;
				pixels[p + 1] = (gSum * mulSum) >> shgSum;
				pixels[p + 2] = (bSum * mulSum) >> shgSum;

				rSum -= rOutSum;
				gSum -= gOutSum;
				bSum -= bOutSum;

				rOutSum -= stackIn.r;
				gOutSum -= stackIn.g;
				bOutSum -= stackIn.b;

				p = (x + (((p = y + radiusPlus1) < (height - 1) ? p : (height - 1)) * width)) << 2;

				rSum += (rInSum += (stackIn.r = pixels[p]));
				gSum += (gInSum += (stackIn.g = pixels[p + 1]));
				bSum += (bInSum += (stackIn.b = pixels[p + 2]));

				stackIn = stackIn.next;

				rOutSum += (pr = stackOut.r);
				gOutSum += (pg = stackOut.g);
				bOutSum += (pb = stackOut.b);

				rInSum -= pr;
				gInSum -= pg;
				bInSum -= pb;

				stackOut = stackOut.next;

				yi += width;
			}
		}

		context.putImageData(imageData, 0, 0);

	};

	/**
	 * Defines a new helper object for Stack Blur Algorithm.
	 */
	function BlurStack() {
		this.r = 0;
		this.g = 0;
		this.b = 0;
		this.next = null;
	}

	/**
	 * Defines a gravity matrix object which handles collision detection.
	 * @param x number of columns in the matrix
	 * @param y number of rows in the matrix
	 * @param r grid size
	 */
	function CollisionMatrix(x, y, r) {
		this.resolution = r;
		this.xc = x;
		this.yc = y;
		this.matrix = new Array(x);
		for (var i = 0; i <= (x + 5); i++) {
			this.matrix[i] = new Array(y);
			for (var j = 0; j <= (y + 5); ++j) {
				this.matrix[i][j] = new DropItem(null);
			}
		}
	}

	/**
	 * Updates position of the given drop on the collision matrix.
	 * @param drop raindrop to be positioned/repositioned
	 * @param forceDelete if true the raindrop will be removed from the matrix
	 * @returns collisions if any
	 */
	CollisionMatrix.prototype.update = function(drop, forceDelete) {
		if (drop.gid) {
			if (!this.matrix[drop.gmx] || !this.matrix[drop.gmx][drop.gmy]) {
				return null;
			}
			this.matrix[drop.gmx][drop.gmy].remove(drop);
			if (forceDelete) {
				return null;
			}

			drop.gmx = Math.floor(drop.x / this.resolution);
			drop.gmy = Math.floor(drop.y / this.resolution);
			if (!this.matrix[drop.gmx] || !this.matrix[drop.gmx][drop.gmy]) {
				return null;
			}
			this.matrix[drop.gmx][drop.gmy].add(drop);

			var collisions = this.collisions(drop);
			if (collisions && collisions.next != null) {
				return collisions.next;
			}
		} else {
			drop.gid = Math.random().toString(36).substr(2, 9);
			drop.gmx = Math.floor(drop.x / this.resolution);
			drop.gmy = Math.floor(drop.y / this.resolution);
			if (!this.matrix[drop.gmx] || !this.matrix[drop.gmx][drop.gmy]) {
				return null;
			}

			this.matrix[drop.gmx][drop.gmy].add(drop);
		}
		return null;
	};

	/**
	 * Looks for collisions with the given raindrop.
	 * @param drop raindrop to be checked
	 * @returns DropItem list of drops that collide with it
	 */
	CollisionMatrix.prototype.collisions = function(drop) {
		var item = new DropItem(null);
		var first = item;

		item = this.addAll(item, drop.gmx - 1, drop.gmy + 1);
		item = this.addAll(item, drop.gmx, drop.gmy + 1);
		item = this.addAll(item, drop.gmx + 1, drop.gmy + 1);

		return first;
	};

	/**
	 * Appends all found drop at a given location to the given item.
	 * @param to item to which the results will be appended to
	 * @param x x position in the matrix
	 * @param y y position in the matrix
	 * @returns last discovered item on the list
	 */
	CollisionMatrix.prototype.addAll = function(to, x, y) {
		if (x > 0 && y > 0 && x < this.xc && y < this.yc) {
			var items = this.matrix[x][y];
			while (items.next != null) {
				items = items.next;
				to.next = new DropItem(items.drop);
				to = to.next;
			}
		}
		return to;
	};

	/**
	 * Removed the drop from its current position
	 * @param drop to be removed
	 */
	CollisionMatrix.prototype.remove = function(drop) {
		this.matrix[drop.gmx][drop.gmy].remove(drop);
	};

	/**
	 * Defines a linked list item.
	 */
	function DropItem(drop) {
		this.drop = drop;
		this.next = null;
	}

	/**
	 * Adds the raindrop to the end of the list.
	 * @param drop raindrop to be added
	 */
	DropItem.prototype.add = function(drop) {
		var item = this;
		while (item.next != null) {
			item = item.next;
		}
		item.next = new DropItem(drop);
	};

	/**
	 * Removes the raindrop from the list.
	 * @param drop raindrop to be removed
	 */
	DropItem.prototype.remove = function(drop) {
		var item = this;
		var prevItem = null;
		while (item.next != null) {
			prevItem = item;
			item = item.next;
			if (item.drop.gid === drop.gid) {
				prevItem.next = item.next;
			}
		}
	};
</script>

<script>
	//Matrix2D
	/*
	 * Matrix2D by Grant Skinner. Dec 5, 2010
	 * Visit http://easeljs.com/ for documentation, updates and examples.
	 *
	 *
	 * Copyright (c) 2010 Grant Skinner
	 *
	 * Permission is hereby granted, free of charge, to any person
	 * obtaining a copy of this software and associated documentation
	 * files (the "Software"), to deal in the Software without
	 * restriction, including without limitation the rights to use,
	 * copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the
	 * Software is furnished to do so, subject to the following
	 * conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	 * OTHER DEALINGS IN THE SOFTWARE.
	 */

	/**
	 * The Easel Javascript library provides a retained graphics mode for canvas
	 * including a full, hierarchical display list, a core interaction model, and
	 * helper classes to make working with Canvas much easier.
	 * @module EaselJS
	 **/

	(function(window) {

		/**
		 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrixes.
		 * @class Matrix2D
		 * @constructor
		 * @param {Number} a Specifies the a property for the new matrix.
		 * @param {Number} b Specifies the b property for the new matrix.
		 * @param {Number} c Specifies the c property for the new matrix.
		 * @param {Number} d Specifies the d property for the new matrix.
		 * @param {Number} tx Specifies the tx property for the new matrix.
		 * @param {Number} ty Specifies the ty property for the new matrix.
		 **/
		var Matrix2D = function(a, b, c, d, tx, ty) {
			this.initialize(a, b, c, d, tx, ty);
		}
		var p = Matrix2D.prototype;

// static public properties:

		/**
		 * An identity matrix, representing a null transformation. Read-only.
		 * @property identity
		 * @static
		 * @type Matrix2D
		 **/
		Matrix2D.identity = null; // set at bottom of class definition.

		/**
		 * Multiplier for converting degrees to radians. Used internally by Matrix2D. Read-only.
		 * @property DEG_TO_RAD
		 * @static
		 * @final
		 * @type Number
		 **/
		Matrix2D.DEG_TO_RAD = Math.PI/180;


// public properties:
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
		p.a = 1;

		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
		p.b = 0;

		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
		p.c = 0;

		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
		p.d = 1;

		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property atx
		 * @type Number
		 **/
		p.tx = 0;

		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
		p.ty = 0;

		/**
		 * Property representing the alpha that will be applied to a display object. This is not part of matrix
		 * operations, but is used for operations like getConcatenatedMatrix to provide concatenated alpha values.
		 * @property alpha
		 * @type Number
		 **/
		p.alpha = 1;

		/**
		 * Property representing the shadow that will be applied to a display object. This is not part of matrix
		 * operations, but is used for operations like getConcatenatedMatrix to provide concatenated shadow values.
		 * @property shadow
		 * @type Shadow
		 **/
		p.shadow  = null;

		/**
		 * Property representing the compositeOperation that will be applied to a display object. This is not part of
		 * matrix operations, but is used for operations like getConcatenatedMatrix to provide concatenated
		 * compositeOperation values. You can find a list of valid composite operations at:
		 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
		 * @property compositeOperation
		 * @type String
		 **/
		p.compositeOperation  = null;

// constructor:
		/**
		 * Initialization method.
		 * @method initialize
		 * @protected
		 */
		p.initialize = function(a, b, c, d, tx, ty) {
			if (a != null) { this.a = a; }
			this.b = b || 0;
			this.c = c || 0;
			if (d != null) { this.d = d; }
			this.tx = tx || 0;
			this.ty = ty || 0;
		}

// public methods:
		/**
		 * Concatenates the specified matrix properties with this matrix. All parameters are required.
		 * @method prepend
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 **/
		p.prepend = function(a, b, c, d, tx, ty) {
			var n11 = a * this.a + b * this.c;
			var n12 = a * this.b + b * this.d;
			var n21 = c * this.a + d * this.c;
			var n22 = c * this.b + d * this.d;
			var n31 = tx * this.a + ty * this.c + this.tx;
			var n32 = tx * this.b + ty * this.d + this.ty;

			this.a  = n11;
			this.b  = n12;
			this.c  = n21;
			this.d  = n22;
			this.tx = n31;
			this.ty = n32;
		}

		/**
		 * Appends the specified matrix properties with this matrix. All parameters are required.
		 * @method append
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 **/
		p.append = function(a, b, c, d, tx, ty) {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;

			this.a  = a*a1+b*c1;
			this.b  = a*b1+b*d1;
			this.c  = c*a1+d*c1;
			this.d  = c*b1+d*d1;
			this.tx = tx*a1+ty*c1+this.tx;
			this.ty = tx*b1+ty*d1+this.ty;

		}

		/**
		 * Prepends the specified matrix with this matrix.
		 * @method prependMatrix
		 * @param {Matrix2D} matrix
		 **/
		p.prependMatrix = function(matrix) {
			this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
			this.prependProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
		}

		/**
		 * Appends the specified matrix with this matrix.
		 * @method appendMatrix
		 * @param {Matrix2D} matrix
		 **/
		p.appendMatrix = function(matrix) {
			this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
			this.appendProperties(matrix.alpha, matrix.shadow,  matrix.compositeOperation);
		}

		/**
		 * Generates matrix properties from the specified display object transform properties, and prepends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new Matrix2D();
		 * mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method prependTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 **/
		p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (regX || regY) {
				// append the registration offset:
				this.tx -= regX; this.ty -= regY;
			}
			if (skewX || skewY) {
				// TODO: can this be combined into a single prepend operation?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
				this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			} else {
				this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}

		}

		/**
		 * Generates matrix properties from the specified display object transform properties, and appends them with this matrix.
		 * For example, you can use this to generate a matrix from a display object: var mtx = new Matrix2D();
		 * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
		 * @method appendTransform
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Number} rotation
		 * @param {Number} skewX
		 * @param {Number} skewY
		 * @param {Number} regX Optional.
		 * @param {Number} regY Optional.
		 **/
		p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
			if (rotation%360 == 0 && scaleX == 1 && scaleY == 1 && skewX == 0 && skewY == 0) {
				this.tx += x-regX;
				this.ty += y-regY;
				return;
			}

			if (rotation%360) {
				var r = rotation*Matrix2D.DEG_TO_RAD;
				var cos = Math.cos(r);
				var sin = Math.sin(r);
			} else {
				cos = 1;
				sin = 0;
			}

			if (skewX || skewY) {
				// TODO: can this be combined into a single append?
				skewX *= Matrix2D.DEG_TO_RAD;
				skewY *= Matrix2D.DEG_TO_RAD;
				this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			} else {
				this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
			}

			if (regX || regY) {
				// prepend the registration offset:
				this.tx -= regX*this.a+regY*this.c;
				this.ty -= regX*this.b+regY*this.d;
			}
		}

		/**
		 * Applies a rotation transformation to the matrix.
		 * @method rotate
		 * @param {Number} angle The angle in rads.
		 **/
		p.rotate = function(angle) {
			var sin = Math.sin(angle);
			var cos = Math.cos(angle);
			var n11 = cos * this.a + sin * this.c;
			var n12 = cos * this.b + sin * this.d;
			var n21 = -sin * this.a + cos * this.c;
			var n22 = -sin * this.b + cos * this.d;
			this.a  = n11;
			this.b  = n12;
			this.c  = n21;
			this.d  = n22;
		}

		/**
		 * Applies a skew transformation to the matrix.
		 * @method skew
		 * @param {Number} skewX The amount to skew horizontally in degrees.
		 * @param {Number} skewY The amount to skew vertically in degrees.
		 */
		p.skew = function(skewX, skewY) {
			skewX = skewX*Matrix2D.DEG_TO_RAD;
			skewY = skewY*Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		}

		/**
		 * Applies a scale transformation to the matrix.
		 * @method scale
		 * @param {Number} x
		 * @param {Number} y
		 **/
		p.scale = function(x, y) {
			this.a *= x;
			this.d *= y;
			this.tx *= x;
			this.ty *= y;
		}

		/**
		 * Translates the matrix on the x and y axes.
		 * @method translate
		 * @param {Number} x
		 * @param {Number} y
		 **/
		p.translate = function(x, y) {
			this.tx += x;
			this.ty += y;
		}

		/**
		 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
		 * @method identity
		 **/
		p.identity = function() {
			this.alpha = this.a = this.d = 1;
			this.b = this.c = this.tx = this.ty = 0;
			this.shadow = this.compositeOperation = null;
		}

		/**
		 * Inverts the matrix, causing it to perform the opposite transformation.
		 * @method invert
		 **/
		p.invert = function() {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var n = a1*d1-b1*c1;

			this.a = d1/n;
			this.b = -b1/n;
			this.c = -c1/n;
			this.d = a1/n;
			this.tx = (c1*this.ty-d1*tx1)/n;
			this.ty = -(a1*this.ty-b1*tx1)/n;
		}

		/**
		 * Returns true if the matrix is an identity matrix.
		 * @method isIdentity
		 * @returns Boolean
		 **/
		p.isIdentity = function() {
			return this.tx == 0 && this.ty == 0 && this.a == 1 && this.b == 0 && this.c == 0 && this.d == 1;
		}

		/**
		 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that this these values
		 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
		 * results.
		 * @method decompose
		 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
		 */
		p.decompose = function(target) {
			// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation
			// even when scale is negative
			if (target == null) { target = {}; }
			target.x = this.tx;
			target.y = this.ty;
			target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
			target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

			var skewX = Math.atan2(-this.c, this.d);
			var skewY = Math.atan2(this.b, this.a);

			if (skewX == skewY) {
				target.rotation = skewY/Matrix2D.DEG_TO_RAD;
				if (this.a < 0 && this.d >= 0) {
					target.rotation += (target.rotation <= 0) ? 180 : -180;
				}
				target.skewX = target.skewY = 0;
			} else {
				target.skewX = skewX/Matrix2D.DEG_TO_RAD;
				target.skewY = skewY/Matrix2D.DEG_TO_RAD;
			}
			return target;
		}

		/**
		 * Reinitializes all matrix properties to those specified.
		 * @method appendProperties
		 * @param {Number} a
		 * @param {Number} b
		 * @param {Number} c
		 * @param {Number} d
		 * @param {Number} tx
		 * @param {Number} ty
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 */
		p.reinitialize = function(a,b,c,d,tx,ty,alpha,shadow,compositeOperation) {
			this.initialize(a,b,c,d,tx,ty);
			this.alpha = alpha || 1;
			this.shadow = shadow;
			this.compositeOperation = compositeOperation;
			return this;
		}

		/**
		 * Appends the specified visual properties to the current matrix.
		 * @method appendProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 */
		p.appendProperties = function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = shadow || this.shadow;
			this.compositeOperation = compositeOperation || this.compositeOperation;
		}

		/**
		 * Prepends the specified visual properties to the current matrix.
		 * @method prependProperties
		 * @param {Number} alpha desired alpha value
		 * @param {Shadow} shadow desired shadow value
		 * @param {String} compositeOperation desired composite operation value
		 */
		p.prependProperties = function(alpha, shadow, compositeOperation) {
			this.alpha *= alpha;
			this.shadow = this.shadow || shadow;
			this.compositeOperation = this.compositeOperation || compositeOperation;
		}

		/**
		 * Returns a clone of the Matrix2D instance.
		 * @method clone
		 * @return {Matrix2D} a clone of the Matrix2D instance.
		 **/
		p.clone = function() {
			var mtx = new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
			mtx.shadow = this.shadow;
			mtx.alpha = this.alpha;
			mtx.compositeOperation = this.compositeOperation;
			return mtx;
		}

		/**
		 * Returns a string representation of this object.
		 * @method toString
		 * @return {String} a string representation of the instance.
		 **/
		p.toString = function() {
			return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
		}

		// this has to be populated after the class is defined:
		Matrix2D.identity = new Matrix2D(1, 0, 0, 1, 0, 0);

		window.Matrix2D = Matrix2D;
	}(window));
</script>
<script>
	// Draw Worm
	// Originally forked from flash project - http://wonderfl.net/c/9os2
	//
	//
	// Click to clear the canvas.
	//
	function DrawWorm(){

		var canvas;
		var context;

		var width;
		var height;

		var mouse = {x: 0, y: window.innerHeight - 20};

		//Expose the mouse to demo the app.
		this.mouse = mouse;

		var interval;

		var vms = [];

		var MAX_NUM = 100;
		var N = 80;

		var px = 500;
		var py = 500;

		this.initialize = function(){
			canvas  = document.getElementById("canvas");
			context = canvas.getContext('2d');

			width = window.innerWidth;
			height = window.innerHeight;

			canvas.width = width;
			canvas.height = height;

//			canvas.addEventListener('mousemove', MouseMove, false);
//			canvas.addEventListener('click', MouseDown, false);
			canvas.addEventListener('touchmove', MouseMove, false);
			canvas.addEventListener('touchstart', MouseDown, false);

			//Set interval - Bad! - I know!
			var interval = setInterval(Draw, 20);

		}

		var Draw = function(){

			var len = vms.length;
			var i;

			for (i = 0; i < len; i++){

				var o = vms[i];

				if (o.count < N){
					DrawWorm(o);
					o.count++;

				} else {
					len--;
					vms.splice(i, 1);
					i--;
				}
			}

			Check();
		}

		//Takes a worm (obj) param
		var DrawWorm = function (obj){

			if (Math.random() > 0.9){
				obj.tmt.rotate(-obj.r * 2);
				obj.r *= -1;
			}

			obj.vmt.prependMatrix(obj.tmt);

			var cc1x = -obj.w * obj.vmt.c + obj.vmt.tx;
			var cc1y = -obj.w * obj.vmt.d + obj.vmt.ty;

			var pp1x = (obj.c1x + cc1x) / 2;
			var pp1y = (obj.c1y + cc1y) / 2;

			var cc2x = obj.w * obj.vmt.c + obj.vmt.tx;
			var cc2y = obj.w * obj.vmt.d + obj.vmt.ty;

			var pp2x = (obj.c2x + cc2x) / 2;
			var pp2y = (obj.c2y + cc2y) / 2;

			context.fillStyle = '#000000';
			context.strokeStyle = '#000000';
			context.beginPath();

			context.moveTo(obj.p1x , obj.p1y);
			context.quadraticCurveTo(obj.c1x, obj.c1y, pp1x, pp1y);

			context.lineTo(pp2x, pp2y);

			context.quadraticCurveTo(obj.c2x, obj.c2y, obj.p2x, obj.p2y);

			context.closePath();
			context.fill();


			obj.c1x = cc1x;
			obj.c1y = cc1y;
			obj.p1x = pp1x;
			obj.p1y = pp1y;
			obj.c2x = cc2x;
			obj.c2y = cc2y;
			obj.p2x = pp2x;
			obj.p2y = pp2y;
		}

		var Check = function(){

			var x0 = mouse.x;
			var y0 = mouse.y;

			var vx = x0 - px;
			var vy = y0 - py;

			var len = Math.min(Magnitude(vx, vy), 50) + 8;

			if (len < 10){
				return;
			}

			var matrix = new Matrix2D();

			matrix.rotate(-(Math.atan2(vx, vy)));

			matrix.translate(x0, y0);

			createWorm(matrix, len);
			context.beginPath();
			context.strokeStyle = '#000000';
			context.moveTo(px, py);
			context.lineTo(x0, y0);
			context.stroke();
			context.closePath();

			px = x0;
			py = y0;

			//More logic here for afterwards?
		}

		var createWorm = function(mtx, len){

			var angle = Math.random() * (Math.PI/6 - Math.PI/64) + Math.PI/64;

			if(Math.random() > 0.5){
				angle *= -1;
			}


			var tmt = new Matrix2D();
			tmt.scale(0.95, 0.95);
			//tmt.rotate(angle);
			tmt.translate(12, 0);

			var w = 0.5;

			var obj = new Worm();

			obj.c1x = (-w * mtx.c + mtx.tx);
			obj.p1x = (-w * mtx.c + mtx.tx);

			obj.c1y = (-w * mtx.d + mtx.ty);
			obj.p1y = (-w * mtx.d + mtx.ty);

			obj.c2x = (w * mtx.c + mtx.tx);
			obj.p2x = (w * mtx.c + mtx.tx);

			obj.c2y = (w * mtx.d + mtx.ty);
			obj.p2y = (w * mtx.d + mtx.ty);

			obj.vmt = mtx;
			obj.tmt = tmt;

			obj.r = angle;
			obj.w = len/20;
			obj.count = 0;

			vms.push(obj);

			if (vms.length > MAX_NUM){
				vms.shift();
			}
		}

		//Not sure why they do this kinda thing in flash.
		var Worm = function(){
			this.c1x = null;
			this.c1y = null;
			this.c2x = null;
			this.c2y = null;
			this.p1x = null;
			this.p1y = null;
			this.p2x = null;
			this.p2y = null;

			this.w = null;
			this.r = null;

			this.count = null;
			this.vmt = null;
			this.tmt = null;

		}

		//Clear the screen,
		var MouseDown = function(e) {
			e.preventDefault();
			canvas.width = canvas.width;
			vms = [];
		}

		var MouseMove = function(e) {
//			mouse.x = e.layerX - canvas.offsetLeft;
//			mouse.y = e.layerY - canvas.offsetTop;
			mouse.x = e.touches[0].pageX - canvas.offsetLeft;
			mouse.y = e.touches[0].pageY - canvas.offsetTop;
		}

		//Returns Magnitude
		var Magnitude = function(x, y){
			return Math.sqrt((x * x) + (y * y));
		}

	}

	function demoApp() {
		app.mouse.x += 20;
		if (app.mouse.x >= window.innerWidth) {
			window.clearInterval( interval );
		}
	}

	// Start the demo.
	var app, interval;
	setTimeout( function() {

		app = new DrawWorm();
		app.initialize();
		interval = setInterval( demoApp, 20 );
	}, 10 );
</script>

<script>
	//run rainday
	(function run() {
		var image = document.getElementById('background');
		image.onload = function() {
			var engine = new RainyDay({
				image: this
			});
			engine.rain([ [0, 2, 200], [3, 3, 1] ], 300);
		};
		image.crossOrigin = 'anonymous';
		image.src = 'http://maroslaw.github.io/rainyday.js/img/LWDAa.jpg';
	})();
</script>
</body>
</html>
